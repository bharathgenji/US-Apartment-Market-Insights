---
title: "Data_science_Pro"
output:
  pdf_document: default

  html_document: default
date: "2023-10-16"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}


library(readxl)
data<- read_excel("C:/Users/Chinmay/OneDrive/Desktop/Intro to datascience project/cleaned_data.xlsx")


```



```{r}

library(tidyverse)

```

```{r}

install.packages("tidyverse")


# Filter for cities with a certain number of listings
top_cities <- cleaned_data %>%
  count(cityname) %>%
  filter(n > 100) %>%
  pull(cityname)

bed_bath_city_price_filtered <- bed_bath_city_price %>%
  filter(cityname %in% top_cities)

# Plot
ggplot(bed_bath_city_price_filtered, aes(x = bedrooms, y = bathrooms, fill = avg_price)) + 
  geom_raster() +
  scale_fill_gradient(low = "white", high = "red") +
  theme_minimal() +
  labs(title = "Average Rental Price by Number of Bedrooms and Bathrooms",
       x = "Number of Bedrooms",
       y = "Number of Bathrooms",
       fill = "Average Price") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  facet_wrap(~ cityname, scales = "free", ncol = 4)



```

```{r}
tinytex::install_tinytex()
install.packages(tinytex)
```



``` {r}

states_map <- map_data("state")

```




```{r}
# Convert state abbreviations to full names
state.abb2name <- setNames(tolower(state.name), state.abb)

# Map state abbreviations to full names in your dataset
cleaned_data$state_full <- ifelse(cleaned_data$state %in% state.abb, 
                                  state.abb2name[cleaned_data$state], 
                                  NA)

# Calculate average rental prices by full state name
state_avg_prices <- cleaned_data %>%
  filter(!is.na(state_full)) %>%
  group_by(state_full) %>%
  summarize(avg_price = mean(price, na.rm = TRUE))

# Merge the spatial data with the average prices
state_data_merged <- left_join(states_map, state_avg_prices, by = c("region" = "state_full"))

# Plot the choropleth map
ggplot(data = state_data_merged, aes(x = long, y = lat, group = group, fill = avg_price)) +
  geom_polygon(color = "white") +
  scale_fill_gradient(low = "blue", high = "red", na.value = "grey50", name = "Avg. Price") +
  labs(title = "Average Rental Price by State") +
  theme_minimal() +
  coord_fixed(1.3)



```
```{r}
# Plot the enhanced choropleth map
p <- ggplot(data = state_data_merged, aes(x = long, y = lat)) +
  geom_polygon(aes(fill = avg_price, group = group), color = "white") +
  scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = median(state_data_merged$avg_price, na.rm = TRUE),
                       na.value = "grey50", name = "Avg. Price") +
  labs(title = "Average Rental Price by State", subtitle = "Colored by Average Price, Annotated with Median Price") +
  theme_minimal() +
  coord_fixed(1.3) +
  geom_text(data = state_prices_centroids, aes(x = long, y = lat, label = round(median_price, 0)), size = 2.5, check_overlap = TRUE)

# Highlight states with the highest and lowest average prices
highest_state <- state_data_merged$region[which.max(state_data_merged$avg_price)]
lowest_state <- state_data_merged$region[which.min(state_data_merged$avg_price)]
p + annotate("text", x = -70, y = 25, label = paste("Highest:", highest_state), color = "red") +
  annotate("text", x = -70, y = 23, label = paste("Lowest:", lowest_state), color = "blue")




```

```{r}
# Drop the latitude column
all_numeric_clean <- all_numeric_clean %>% select(-latitude)

# Compute the correlation matrix for the remaining columns
cor_matrix_all <- cor(all_numeric_clean)

# Convert the correlation matrix into a tidy format
cor_data_all <- as.data.frame(as.table(cor_matrix_all))

# Plot the correlation heatmap using ggplot2
ggplot(data = cor_data_all, aes(Var1, Var2)) +
  geom_tile(aes(fill = Freq), color = "white") +
  geom_text(aes(label = sprintf("%.2f", Freq)), size = 3) +
  scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0, 
                       limits = c(-1, 1), name = "Correlation") +
  theme_minimal() +
  labs(title = "Correlation between Selected Features", x = "", y = "") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, size = 8),
        axis.text.y = element_text(size = 8))




```

```{r}
# Identify factor columns with only one level
# Convert all factor variables with only one level to character variables
data_with_dummies <- data_with_dummies %>%
  mutate(across(where(is.factor), ~ if(length(levels(.)) <= 1) as.character(.) else .))

# Remove all character columns
data_with_dummies <- data_with_dummies %>%
  select(where(~ !is.character(.)))

# Regression Analysis
formula <- as.formula(paste("price ~ square_feet + bedrooms + bathrooms +", 
                            paste(setdiff(names(data_with_dummies), "price"), collapse = " + ")))
model <- lm(formula, data = data_with_dummies)

# Output the summary of the regression
summary(model)


```

```{r}

# Residuals vs Fitted values plot
ggplot(data = model, aes(x = .fitted, y = .resid)) +
  geom_point(aes(color = .resid), alpha = 0.5) +
  geom_smooth(se = FALSE, method = "loess", color = "red") +
  theme_minimal() +
  labs(title = "Residuals vs. Fitted",
       x = "Fitted values",
       y = "Residuals",
       color = "Residual Value") +
  theme(legend.position = "none")

```
```{r}
# Predicting the prices using the model
predicted_prices = predict(model, data_with_dummies)

# Plotting the actual vs. predicted prices
plot_data = data.frame(Actual = data_with_dummies$price, Predicted = predicted_prices)

ggplot(plot_data, aes(x = Actual, y = Predicted)) +
  geom_point(aes(color = abs(Actual - Predicted)), alpha = 0.5) +
  geom_smooth(method = "lm", se = FALSE, color = "red") +
  labs(title = "Actual vs. Predicted Prices", 
       x = "Actual Prices", 
       y = "Predicted Prices",
       color = "Error") +
  theme_minimal()

```
```{r}
install.packages("lmtest")
library(lmtest)
durbinWatsonTest(model)


```